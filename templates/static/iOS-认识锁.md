
pid: 190115;
tag: iOS;

---

# iOS-认识锁

> 认识开发中常见的锁及作用

首先一些概念定义:  
临界区:指的是一块对公共资源进行访问的代码.  

互斥锁:是一种用于多线程编程中,防止两条线程同时对同一公共资源进行读写的机制.该目的通过将代码切片成一个一个的临界区而达成. <!--more-->  
自旋锁:是用于多线程同步的一种锁,线程反复检查锁变量是否可用.  
条件锁:就是条件变量,当进程的某些资源要求不满足时就进入休眠,也就是锁住了.当资源被分配到了,条件锁打开,进程继续运行.  
读写锁:用于解决多线程对公共资源读写问题.读操作可并发重入,写操作是互斥的.读写锁通常用互斥锁,条件变量,信号量实现.  
信号量:是一种更高级的同步机制.信号量可以有更多的取值空间,用来实现更加复杂的同步,而不单单是线程间互斥.  

### 互斥锁

> 互斥锁的实现原理与信号量非常相似,不是使用忙等,而是阻塞线程并睡眠,需要进行上下文切换

#### NSLock

#### pthread_mutex

#### @synchronized
这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读.  
我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁.  
你调用 sychronized 的每个对象，Objective-C runtime 都会为其分配一个递归锁并存储在哈希表中.  
具体的实现原理可以参考这篇文章: [关于 @synchronized，这儿比你想知道的还要多](http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/);  

### 自旋锁

> 自旋锁是为了确保临界区只有一个线程可以访问

#### OSSpinLock(iOS10后不再使用)

#### os_unfair_lock(iOS10后用来替换OSSpinLock)

### 读写锁

#### pthread_rwlock

### 递归锁

#### NSRecursiveLock

#### pthread_mutex(recursive)

### 条件锁

#### NSCondition

NSCondition 的底层是通过条件变量(condition variable)pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程.


#### NSConditionLock

### 信号量

#### dispatch_semaphore

## 自旋锁和互斥锁的对比

相同点:都能保证同一时间只有一个线程访问共享资源.都能保证线程安全.  
不同点:  
    互斥锁:如果共享数据已经有其他线程加锁了,线程会进入休眠状态等待锁.一旦被访问的资源被解锁,则等待资源的线程会被唤醒.  
    自旋锁:如果共享数据已经有其他线程加锁了,线程会以死循环的方式等待锁,一旦被访问的资源被解锁,则等待资源的线程会立即执行.  
自旋锁的效率高于互斥锁.

两种锁的加锁原理：  
互斥锁：线程会从sleep（加锁）——>running（解锁），过程中有上下文的切换(主动出让时间片，线程休眠，等待下一次唤醒)，cpu的抢占，信号的发送等开销。  
自旋锁：线程一直是running(加锁——>解锁)，死循环（忙等 do-while）检测锁的标志位，机制不复杂。  

### 最后
本文一些内容参考了:  
[深入理解 iOS 开发中的锁](https://juejin.im/post/57f6e9f85bbb50005b126e5f);  
[关于 @synchronized，这儿比你想知道的还要多](http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/);  
